package com.mdgtaxi.service;

import com.mdgtaxi.entity.Chauffeur;
import com.mdgtaxi.entity.ChauffeurMouvementStatut;
import com.mdgtaxi.util.HibernateUtil;
import com.mdgtaxi.view.VmChauffeurActivite;
import com.mdgtaxi.view.VmChauffeurDetail;



import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class ChauffeurService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    // CRUD Operations for Chauffeur

    /**
     * Get chauffeur detail view by ID
     */
    public VmChauffeurDetail getChauffeurDetailById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(VmChauffeurDetail.class, id);
        } finally {
            em.close();
        }
    }

    /**
     * Get all chauffeur details
     */
    public List<VmChauffeurDetail> getAllChauffeurDetails() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<VmChauffeurDetail> query = em.createQuery(
                    "SELECT cd FROM VmChauffeurDetail cd",
                    VmChauffeurDetail.class
            );
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    /**
     * Get chauffeur activity by ID
     */
    public VmChauffeurActivite getChauffeurActivite(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(VmChauffeurActivite.class, id);
        } finally {
            em.close();
        }
    }

    public Chauffeur createChauffeur(Chauffeur chauffeur) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(chauffeur);
            tx.commit();
            return chauffeur;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public Chauffeur getChauffeurById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(Chauffeur.class, id);
        } finally {
            em.close();
        }
    }

    public List<Chauffeur> getAllChauffeurs() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Chauffeur> query = em.createQuery("SELECT c FROM Chauffeur c", Chauffeur.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public Chauffeur updateChauffeur(Chauffeur chauffeur) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Chauffeur updated = em.merge(chauffeur);
            tx.commit();
            return updated;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public void deleteChauffeur(Long id) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Chauffeur chauffeur = em.find(Chauffeur.class, id);
            if (chauffeur != null) {
                em.remove(chauffeur);
            }
            tx.commit();
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }



    // Operations for Related Entities

    public ChauffeurMouvementStatut changeStatut(ChauffeurMouvementStatut mouvement) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(mouvement);
            tx.commit();
            return mouvement;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public List<ChauffeurMouvementStatut> getMouvementsByChauffeur(Long idChauffeur) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<ChauffeurMouvementStatut> query = em.createQuery(
                    "SELECT cms FROM ChauffeurMouvementStatut cms WHERE cms.chauffeur.id = :idChauffeur ORDER BY cms.dateMouvement DESC",
                    ChauffeurMouvementStatut.class);
            query.setParameter("idChauffeur", idChauffeur);
            return query.getResultList();
        } finally {
            em.close();
        }
    }


    public List<Chauffeur> searchChauffeursWithFilters(Map<String, Object> filters) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Chauffeur> cq = cb.createQuery(Chauffeur.class);
            Root<Chauffeur> root = cq.from(Chauffeur.class);

            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();

                if (value == null) continue;

                switch (key) {
                    case "nom":
                        predicates.add(cb.equal(root.get("nom"), value));
                        break;
                    case "prenom":
                        predicates.add(cb.equal(root.get("prenom"), value));
                        break;
                    case "dateNaissance":
                        predicates.add(cb.equal(root.get("dateNaissance"), value));
                        break;
                    case "numeroPermis":
                        predicates.add(cb.equal(root.get("numeroPermis"), value));
                        break;
                    // Add more fields as needed
                    default:
                        // Ignore unknown filters
                        break;
                }
            }

            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }

            TypedQuery<Chauffeur> query = em.createQuery(cq);
            return query.getResultList();
        } finally {
            em.close();
        }
    }


}
package com.mdgtaxi.service;

import com.mdgtaxi.entity.Client;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.TypedQuery;
import java.util.List;

public class ClientService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    public List<Client> getAllClients() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Client> query = em.createQuery("SELECT c FROM Client c", Client.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public Client createClient(Client client) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(client);
            tx.commit();
            return client;
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.dto.EntityDetailWithStatusDto;
import com.mdgtaxi.dto.EntityListWithStatusDto;
import com.mdgtaxi.dto.EntityStatusCriteria;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.TypedQuery;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Service pour rÃ©cupÃ©rer des entitÃ©s avec leurs statuts selon diffÃ©rents critÃ¨res
 * Supporte: Chauffeur, Vehicule, Trajet, Trajet_Reservation
 */
public class EntityStatusService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    /**
     * RÃ©cupÃ¨re toutes les entitÃ©s avec leur statut Ã  une date donnÃ©e
     * @param tableName Nom de la table (Chauffeur, Vehicule, Trajet, Trajet_Reservation)
     * @param date Date (null = maintenant)
     * @return EntityListWithStatusDto contenant toutes les entitÃ©s avec leurs statuts
     */
    public EntityListWithStatusDto getAllEntitiesWithStatusAtDate(String tableName, LocalDateTime date) {
        if (date == null) {
            date = LocalDateTime.now();
        }

        String entityName = getEntityName(tableName);
        String mouvementEntity = getMouvementEntityName(tableName);
        String statusEntity = getStatusEntityName(tableName);
        String idField = getIdFieldName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            // RequÃªte pour rÃ©cupÃ©rer les entitÃ©s avec leur statut actuel
            String jpql = "SELECT e, s.id, s.libelle, s.score, s.spanHtml " +
                    "FROM " + entityName + " e " +
                    "LEFT JOIN " + mouvementEntity + " m ON e.id = m." + idField + " " +
                    "LEFT JOIN " + statusEntity + " s ON m.nouveauStatut.id = s.id " +
                    "WHERE m.dateMouvement = (" +
                    "  SELECT MAX(m2.dateMouvement) " +
                    "  FROM " + mouvementEntity + " m2 " +
                    "  WHERE m2." + idField + " = e.id " +
                    "  AND m2.dateMouvement <= :date" +
                    ") " +
                    "OR NOT EXISTS (" +
                    "  SELECT 1 FROM " + mouvementEntity + " m3 " +
                    "  WHERE m3." + idField + " = e.id" +
                    ")";

            TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);
            query.setParameter("date", date);
            List<Object[]> results = query.getResultList();

            List<EntityDetailWithStatusDto> entities = new ArrayList<>();
            for (Object[] row : results) {
                entities.add(new EntityDetailWithStatusDto(
                        row[0],  // entity
                        (Long) row[1],  // idStatut
                        (String) row[2],  // libelleStatut
                        (Integer) row[3],  // scoreStatut
                        (String) row[4]  // spanHtmlStatut
                ));
            }

            return new EntityListWithStatusDto(entities, date, (long) entities.size());
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re les entitÃ©s selon des critÃ¨res de statut multiples
     * @param tableName Nom de la table
     * @param criteria CritÃ¨res de recherche (libellÃ©, score min/max, date)
     * @return EntityListWithStatusDto contenant les entitÃ©s filtrÃ©es
     */
    public EntityListWithStatusDto getEntitiesByCriteria(String tableName, EntityStatusCriteria criteria) {
        LocalDateTime effectiveDate = criteria.getEffectiveDate();

        String entityName = getEntityName(tableName);
        String mouvementEntity = getMouvementEntityName(tableName);
        String statusEntity = getStatusEntityName(tableName);
        String idField = getIdFieldName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            // Construction dynamique de la requÃªte avec les critÃ¨res
            StringBuilder jpql = new StringBuilder();
            jpql.append("SELECT e, s.id, s.libelle, s.score, s.spanHtml ")
                    .append("FROM ").append(entityName).append(" e ")
                    .append("INNER JOIN ").append(mouvementEntity).append(" m ON e.id = m.").append(idField).append(" ")
                    .append("INNER JOIN ").append(statusEntity).append(" s ON m.nouveauStatut.id = s.id ")
                    .append("WHERE m.dateMouvement <= :date ")
                    .append("AND m.dateMouvement = (")
                    .append("  SELECT MAX(m2.dateMouvement) ")
                    .append("  FROM ").append(mouvementEntity).append(" m2 ")
                    .append("  WHERE m2.").append(idField).append(" = e.id ")
                    .append("  AND m2.dateMouvement <= :date")
                    .append(") ");

            // Ajout des critÃ¨res de filtre
            boolean hasStatusCriteria = false;

            if (criteria.getLibelleStatut() != null && !criteria.getLibelleStatut().isEmpty()) {
                jpql.append("AND s.libelle = :libelle ");
                hasStatusCriteria = true;
            }

            if (criteria.getExactScore() != null) {
                jpql.append("AND s.score = :exactScore ");
                hasStatusCriteria = true;
            } else {
                if (criteria.getMinScore() != null) {
                    jpql.append("AND s.score >= :minScore ");
                    hasStatusCriteria = true;
                }
                if (criteria.getMaxScore() != null) {
                    jpql.append("AND s.score <= :maxScore ");
                    hasStatusCriteria = true;
                }
            }

            TypedQuery<Object[]> query = em.createQuery(jpql.toString(), Object[].class);
            query.setParameter("date", effectiveDate);

            if (criteria.getLibelleStatut() != null && !criteria.getLibelleStatut().isEmpty()) {
                query.setParameter("libelle", criteria.getLibelleStatut());
            }
            if (criteria.getExactScore() != null) {
                query.setParameter("exactScore", criteria.getExactScore());
            } else {
                if (criteria.getMinScore() != null) {
                    query.setParameter("minScore", criteria.getMinScore());
                }
                if (criteria.getMaxScore() != null) {
                    query.setParameter("maxScore", criteria.getMaxScore());
                }
            }

            List<Object[]> results = query.getResultList();
            List<EntityDetailWithStatusDto> entities = new ArrayList<>();

            for (Object[] row : results) {
                entities.add(new EntityDetailWithStatusDto(
                        row[0],  // entity
                        (Long) row[1],  // idStatut
                        (String) row[2],  // libelleStatut
                        (Integer) row[3],  // scoreStatut
                        (String) row[4]  // spanHtmlStatut
                ));
            }

            return new EntityListWithStatusDto(entities, effectiveDate, (long) entities.size());
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re les entitÃ©s par libellÃ© de statut Ã  une date donnÃ©e
     * @param tableName Nom de la table
     * @param libelleStatut LibellÃ© du statut
     * @param date Date (null = maintenant)
     * @return EntityListWithStatusDto
     */
    public EntityListWithStatusDto getEntitiesByLibelleStatut(String tableName, String libelleStatut, LocalDateTime date) {
        EntityStatusCriteria criteria = EntityStatusCriteria.builder()
                .libelleStatut(libelleStatut)
                .atDate(date)
                .build();
        return getEntitiesByCriteria(tableName, criteria);
    }

    /**
     * RÃ©cupÃ¨re les entitÃ©s par score exact Ã  une date donnÃ©e
     * @param tableName Nom de la table
     * @param score Score exact
     * @param date Date (null = maintenant)
     * @return EntityListWithStatusDto
     */
    public EntityListWithStatusDto getEntitiesByExactScore(String tableName, int score, LocalDateTime date) {
        EntityStatusCriteria criteria = EntityStatusCriteria.builder()
                .exactScore(score)
                .atDate(date)
                .build();
        return getEntitiesByCriteria(tableName, criteria);
    }

    /**
     * RÃ©cupÃ¨re les entitÃ©s par plage de scores Ã  une date donnÃ©e
     * @param tableName Nom de la table
     * @param minScore Score minimum (null = pas de minimum)
     * @param maxScore Score maximum (null = pas de maximum)
     * @param date Date (null = maintenant)
     * @return EntityListWithStatusDto
     */
    public EntityListWithStatusDto getEntitiesByScoreRange(String tableName, Integer minScore, Integer maxScore, LocalDateTime date) {
        EntityStatusCriteria criteria = EntityStatusCriteria.builder()
                .minScore(minScore)
                .maxScore(maxScore)
                .atDate(date)
                .build();
        return getEntitiesByCriteria(tableName, criteria);
    }

    /**
     * Compte le nombre d'entitÃ©s par statut Ã  une date donnÃ©e
     * @param tableName Nom de la table
     * @param date Date (null = maintenant)
     * @return Liste de tableaux [libelle_statut, count]
     */
    public List<Object[]> countEntitiesByStatusAtDate(String tableName, LocalDateTime date) {
        if (date == null) {
            date = LocalDateTime.now();
        }

        String mouvementEntity = getMouvementEntityName(tableName);
        String statusEntity = getStatusEntityName(tableName);
        String idField = getIdFieldName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT s.libelle, COUNT(DISTINCT m." + idField + ") " +
                    "FROM " + mouvementEntity + " m " +
                    "INNER JOIN " + statusEntity + " s ON m.nouveauStatut.id = s.id " +
                    "WHERE m.dateMouvement <= :date " +
                    "AND m.dateMouvement = (" +
                    "  SELECT MAX(m2.dateMouvement) " +
                    "  FROM " + mouvementEntity + " m2 " +
                    "  WHERE m2." + idField + " = m." + idField + " " +
                    "  AND m2.dateMouvement <= :date" +
                    ") " +
                    "GROUP BY s.libelle, s.score " +
                    "ORDER BY s.score";

            TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);
            query.setParameter("date", date);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    // MÃ©thodes de mapping

    private String getEntityName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "Chauffeur";
            case "Vehicule" -> "Vehicule";
            case "Trajet" -> "Trajet";
            case "Trajet_Reservation" -> "TrajetReservation";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }

    private String getMouvementEntityName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "ChauffeurMouvementStatut";
            case "Vehicule" -> "VehiculeMouvementStatut";
            case "Trajet" -> "TrajetMouvementStatut";
            case "Trajet_Reservation" -> "TrajetReservationMouvementStatut";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }

    private String getStatusEntityName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "ChauffeurStatut";
            case "Vehicule" -> "VehiculeStatut";
            case "Trajet" -> "TrajetStatut";
            case "Trajet_Reservation" -> "ReservationStatut";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }

    private String getIdFieldName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "chauffeur.id";
            case "Vehicule" -> "vehicule.id";
            case "Trajet" -> "trajet.id";
            case "Trajet_Reservation" -> "trajetReservation.id";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.entity.Ligne;
import com.mdgtaxi.entity.LigneDetail;
import com.mdgtaxi.entity.Trajet;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.math.BigDecimal;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class LigneService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    public List<LigneDetail> getLigneDetailList (Long idLigne) {

        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<LigneDetail> query = em.createQuery(
                    "SELECT l FROM LigneDetail l WHERE l.ligne.id = :ligneId",
                    LigneDetail.class
            );
            query.setParameter("ligneId", idLigne);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public List<Ligne> searchLignesWithFilters(Map<String, Object> filters) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Ligne> cq = cb.createQuery(Ligne.class);
            Root<Ligne> root = cq.from(Ligne.class);

            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();

                if (value == null) continue;

                switch (key) {
                    case "distanceKm":
                        predicates.add(cb.equal(root.get("distanceKm"), value));
                        break;
                    case "distanceKm>=":
                        predicates.add(cb.greaterThanOrEqualTo(root.get("distanceKm"), (BigDecimal) value));
                        break;
                    case "distanceKm<=":
                        predicates.add(cb.lessThanOrEqualTo(root.get("distanceKm"), (BigDecimal) value));
                        break;
                    case "villeDepart.id":
                        predicates.add(cb.equal(root.get("villeDepart").get("id"), value));
                        break;
                    case "villeArrivee.id":
                        predicates.add(cb.equal(root.get("villeArrivee").get("id"), value));
                        break;
                    default:
                        // Ignore unknown filters
                        break;
                }
            }

            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }

            TypedQuery<Ligne> query = em.createQuery(cq);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public Ligne createLigne(Ligne ligne) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(ligne);
            tx.commit();
            return ligne;
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public Ligne getLigneById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(Ligne.class, id);
        } finally {
            em.close();
        }
    }

    public List<Ligne> getAllLignes() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Ligne> query = em.createQuery("SELECT l FROM Ligne l", Ligne.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public Ligne updateLigne(Ligne ligne) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Ligne updated = em.merge(ligne);
            tx.commit();
            return updated;
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public void deleteLigne(Long id) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Ligne ligne = em.find(Ligne.class, id);
            if (ligne != null) {
                em.remove(ligne);
            }
            tx.commit();
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.entity.*;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.LocalDateTime;

public class MouvementStatusCreateService {
    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    /**
     * Creates a new mouvement statut for the given entity.
     * Updates the entity's current statut field if applicable.
     *
     * @param tableName      Name of the table (e.g., "Chauffeur", "Vehicule",
     *                       "Trajet", "Trajet_Reservation")
     * @param idEntity       ID of the entity
     * @param idNewStatut    ID of the new statut
     * @param dateChangement Date of the changement
     * @param observation    Optional observation
     * @return The created mouvement statut object
     */
    public Object createMouvementStatut(String tableName, Long idEntity, Long idNewStatut, LocalDateTime dateChangement,
            String observation) {
        Class<?> entityClass = null;
        Class<?> mouvementClass = null;
        Class<?> statutClass = null;
        String entityField = null;
        boolean hasStatutField = false;
        String statutFieldName = null;

        if ("Chauffeur".equals(tableName)) {
            entityClass = Chauffeur.class;
            mouvementClass = ChauffeurMouvementStatut.class;
            statutClass = ChauffeurStatut.class;
            entityField = "chauffeur";
            hasStatutField = false;
        } else if ("Vehicule".equals(tableName)) {
            entityClass = Vehicule.class;
            mouvementClass = VehiculeMouvementStatut.class;
            statutClass = VehiculeStatut.class;
            entityField = "vehicule";
            hasStatutField = false;
        } else if ("Trajet".equals(tableName)) {
            entityClass = Trajet.class;
            mouvementClass = TrajetMouvementStatut.class;
            statutClass = TrajetStatut.class;
            entityField = "trajet";
            hasStatutField = true;
            statutFieldName = "trajetStatut";
        } else if ("Trajet_Reservation".equals(tableName)) {
            entityClass = TrajetReservation.class;
            mouvementClass = TrajetReservationMouvementStatut.class;
            statutClass = ReservationStatut.class;
            entityField = "trajetReservation";
            hasStatutField = true;
            statutFieldName = "reservationStatut";
        } else {
            throw new IllegalArgumentException("Unsupported tableName: " + tableName);
        }

        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();

            // Find the entity
            Object entity = em.find(entityClass, idEntity);
            if (entity == null) {
                throw new IllegalArgumentException("Entity not found with id: " + idEntity);
            }

            // Find the new statut
            Object newStatut = em.find(statutClass, idNewStatut);
            if (newStatut == null) {
                throw new IllegalArgumentException("Statut not found with id: " + idNewStatut);
            }

            // Create new mouvement instance
            Object mouvement = mouvementClass.getConstructor().newInstance();

            // Set entity
            Method setEntity = mouvementClass.getMethod("set" + capitalize(entityField), entityClass);
            setEntity.invoke(mouvement, entity);

            // Set nouveauStatut
            Method setNouveauStatut = mouvementClass.getMethod("setNouveauStatut", statutClass);
            setNouveauStatut.invoke(mouvement, newStatut);

            // Set dateMouvement
            Method setDateMouvement = mouvementClass.getMethod("setDateMouvement", LocalDateTime.class);
            setDateMouvement.invoke(mouvement, dateChangement);

            // Set observation
            Method setObservation = mouvementClass.getMethod("setObservation", String.class);
            setObservation.invoke(mouvement, observation);

            // Persist the mouvement
            em.persist(mouvement);

            // If the entity has a direct statut field, update it
            if (hasStatutField) {
                Method setStatut = entityClass.getMethod("set" + capitalize(statutFieldName), statutClass);
                setStatut.invoke(entity, newStatut);
            }

            tx.commit();
            return mouvement;
        } catch (InvocationTargetException | IllegalAccessException | NoSuchMethodException
                | InstantiationException e) {
            if (tx.isActive())
                tx.rollback();
            throw new RuntimeException("Reflection error: " + e.getMessage(), e);
        } finally {
            em.close();
        }
    }

    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

}
package com.mdgtaxi.service;

import com.mdgtaxi.dto.MouvementStatusCriteria;
import com.mdgtaxi.dto.MouvementStatusDto;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.TypedQuery;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Service pour gÃ©rer les mouvements de statut individuels
 * Supporte: Chauffeur, Vehicule, Trajet, Trajet_Reservation
 */
public class MouvementStatusService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    /**
     * RÃ©cupÃ¨re le statut actuel d'une entitÃ©
     * 
     * @param tableName Nom de la table (Chauffeur, Vehicule, Trajet,
     *                  Trajet_Reservation)
     * @param idEntite  ID de l'entitÃ©
     * @return Le statut actuel ou null
     */
    public MouvementStatusDto getCurrentStatus(String tableName, Long idEntite) {
        return getStatusAtDate(tableName, idEntite, LocalDateTime.now());
    }

    /**
     * RÃ©cupÃ¨re le statut d'une entitÃ© Ã  une date donnÃ©e
     * 
     * @param tableName Nom de la table
     * @param idEntite  ID de l'entitÃ©
     * @param date      Date Ã  laquelle on veut connaÃ®tre le statut
     * @return Le statut Ã  cette date ou null
     */
    public MouvementStatusDto getStatusAtDate(String tableName, Long idEntite, LocalDateTime date) {
        String mouvementEntity = getMouvementEntityName(tableName);
        String statusEntity = getStatusEntityName(tableName);
        String idField = getIdFieldName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.MouvementStatusDto(" +
                    "m.id, " +
                    "m." + idField + ", " +
                    "'" + tableName + "', " +
                    "s.id, " +
                    "s.libelle, " +
                    "s.score, " +
                    "s.spanHtml, " +
                    "m.dateMouvement, " +
                    "m.observation) " +
                    "FROM " + mouvementEntity + " m " +
                    "INNER JOIN " + statusEntity + " s ON m.nouveauStatut.id = s.id " +
                    "WHERE m." + idField + " = :idEntite " +
                    "AND m.dateMouvement <= :date " +
                    "ORDER BY m.dateMouvement DESC";

            TypedQuery<MouvementStatusDto> query = em.createQuery(jpql, MouvementStatusDto.class);
            query.setParameter("idEntite", idEntite);
            query.setParameter("date", date);
            query.setMaxResults(1);

            List<MouvementStatusDto> results = query.getResultList();
            return results.isEmpty() ? null : results.get(0);
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re l'historique complet des mouvements de statut
     * 
     * @param tableName Nom de la table
     * @param idEntite  ID de l'entitÃ©
     * @return Liste des mouvements ordonnÃ©s par date dÃ©croissante
     */
    public List<MouvementStatusDto> getStatusHistory(String tableName, Long idEntite) {
        String mouvementEntity = getMouvementEntityName(tableName);
        String statusEntity = getStatusEntityName(tableName);
        String idField = getIdFieldName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.MouvementStatusDto(" +
                    "m.id, " +
                    "m." + idField + ", " +
                    "'" + tableName + "', " +
                    "s.id, " +
                    "s.libelle, " +
                    "s.score, " +
                    "s.spanHtml, " +
                    "m.dateMouvement, " +
                    "m.observation) " +
                    "FROM " + mouvementEntity + " m " +
                    "INNER JOIN " + statusEntity + " s ON m.nouveauStatut.id = s.id " +
                    "WHERE m." + idField + " = :idEntite " +
                    "ORDER BY m.dateMouvement DESC";

            TypedQuery<MouvementStatusDto> query = em.createQuery(jpql, MouvementStatusDto.class);
            query.setParameter("idEntite", idEntite);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re les mouvements de statut selon des critÃ¨res multiples
     * 
     * @param tableName Nom de la table
     * @param criteria  CritÃ¨res de recherche
     * @return Liste des mouvements filtrÃ©s ordonnÃ©s par date dÃ©croissante
     */
    public List<MouvementStatusDto> getMouvementsByCriteria(String tableName, MouvementStatusCriteria criteria) {
        String mouvementEntity = getMouvementEntityName(tableName);
        String statusEntity = getStatusEntityName(tableName);
        String idField = getIdFieldName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            StringBuilder jpql = new StringBuilder();
            jpql.append("SELECT new com.mdgtaxi.dto.MouvementStatusDto(")
                    .append("m.id, ")
                    .append("m.").append(idField).append(", ")
                    .append("'").append(tableName).append("', ")
                    .append("s.id, ")
                    .append("s.libelle, ")
                    .append("s.score, ")
                    .append("s.spanHtml, ")
                    .append("m.dateMouvement, ")
                    .append("m.observation) ")
                    .append("FROM ").append(mouvementEntity).append(" m ")
                    .append("INNER JOIN ").append(statusEntity).append(" s ON m.nouveauStatut.id = s.id ")
                    .append("WHERE 1=1 ");

            // Filtre par ID d'entitÃ©
            if (criteria.getIdEntite() != null) {
                jpql.append("AND m.").append(idField).append(" = :idEntite ");
            }

            // Filtre par libellÃ© nouveau statut
            if (criteria.getLibelleNouveauStatut() != null && !criteria.getLibelleNouveauStatut().isEmpty()) {
                jpql.append("AND s.libelle = :libelleNouveau ");
            }

            // Filtres par score nouveau statut
            if (criteria.getExactScoreNouveau() != null) {
                jpql.append("AND s.score = :exactScoreNouveau ");
            } else {
                if (criteria.getMinScoreNouveau() != null) {
                    jpql.append("AND s.score >= :minScoreNouveau ");
                }
                if (criteria.getMaxScoreNouveau() != null) {
                    jpql.append("AND s.score <= :maxScoreNouveau ");
                }
            }

            // Filtre par plage de dates
            if (criteria.getDateDebut() != null) {
                jpql.append("AND m.dateMouvement >= :dateDebut ");
            }
            if (criteria.getDateFin() != null) {
                jpql.append("AND m.dateMouvement <= :dateFin ");
            }

            // Filtre par observation
            if (criteria.getObservationContains() != null && !criteria.getObservationContains().isEmpty()) {
                jpql.append("AND LOWER(m.observation) LIKE LOWER(:observation) ");
            }

            jpql.append("ORDER BY m.dateMouvement DESC");

            TypedQuery<MouvementStatusDto> query = em.createQuery(jpql.toString(), MouvementStatusDto.class);

            // ParamÃ©trage de la requÃªte
            if (criteria.getIdEntite() != null) {
                query.setParameter("idEntite", criteria.getIdEntite());
            }
            if (criteria.getLibelleNouveauStatut() != null && !criteria.getLibelleNouveauStatut().isEmpty()) {
                query.setParameter("libelleNouveau", criteria.getLibelleNouveauStatut());
            }
            if (criteria.getExactScoreNouveau() != null) {
                query.setParameter("exactScoreNouveau", criteria.getExactScoreNouveau());
            } else {
                if (criteria.getMinScoreNouveau() != null) {
                    query.setParameter("minScoreNouveau", criteria.getMinScoreNouveau());
                }
                if (criteria.getMaxScoreNouveau() != null) {
                    query.setParameter("maxScoreNouveau", criteria.getMaxScoreNouveau());
                }
            }
            if (criteria.getDateDebut() != null) {
                query.setParameter("dateDebut", criteria.getDateDebut());
            }
            if (criteria.getDateFin() != null) {
                query.setParameter("dateFin", criteria.getDateFin());
            }
            if (criteria.getObservationContains() != null && !criteria.getObservationContains().isEmpty()) {
                query.setParameter("observation", "%" + criteria.getObservationContains() + "%");
            }

            return query.getResultList();
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re tous les mouvements pour une table (sans filtre d'entitÃ© spÃ©cifique)
     * 
     * @param tableName Nom de la table
     * @return Liste de tous les mouvements
     */
    public List<MouvementStatusDto> getAllMouvements(String tableName) {
        MouvementStatusCriteria criteria = MouvementStatusCriteria.builder().build();
        return getMouvementsByCriteria(tableName, criteria);
    }

    /**
     * RÃ©cupÃ¨re les mouvements dans une pÃ©riode donnÃ©e
     * 
     * @param tableName Nom de la table
     * @param dateDebut Date de dÃ©but
     * @param dateFin   Date de fin
     * @return Liste des mouvements dans la pÃ©riode
     */
    public List<MouvementStatusDto> getMouvementsByPeriod(String tableName, LocalDateTime dateDebut,
            LocalDateTime dateFin) {
        MouvementStatusCriteria criteria = MouvementStatusCriteria.builder()
                .dateDebut(dateDebut)
                .dateFin(dateFin)
                .build();
        return getMouvementsByCriteria(tableName, criteria);
    }

    /**
     * RÃ©cupÃ¨re les mouvements vers un statut spÃ©cifique
     * 
     * @param tableName            Nom de la table
     * @param libelleNouveauStatut LibellÃ© du nouveau statut
     * @return Liste des mouvements vers ce statut
     */
    public List<MouvementStatusDto> getMouvementsToStatus(String tableName, String libelleNouveauStatut) {
        MouvementStatusCriteria criteria = MouvementStatusCriteria.builder()
                .libelleNouveauStatut(libelleNouveauStatut)
                .build();
        return getMouvementsByCriteria(tableName, criteria);
    }

    // MÃ©thodes de mapping

    private String getMouvementEntityName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "ChauffeurMouvementStatut";
            case "Vehicule" -> "VehiculeMouvementStatut";
            case "Trajet" -> "TrajetMouvementStatut";
            case "Trajet_Reservation" -> "TrajetReservationMouvementStatut";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }

    private String getStatusEntityName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "ChauffeurStatut";
            case "Vehicule" -> "VehiculeStatut";
            case "Trajet" -> "TrajetStatut";
            case "Trajet_Reservation" -> "ReservationStatut";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }

    private String getIdFieldName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "chauffeur.id";
            case "Vehicule" -> "vehicule.id";
            case "Trajet" -> "trajet.id";
            case "Trajet_Reservation" -> "trajetReservation.id";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.entity.Trajet;
import com.mdgtaxi.entity.TrajetReservation;
import com.mdgtaxi.entity.TrajetReservationMouvementStatut;
import com.mdgtaxi.entity.TrajetReservationPaiement;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ReservationService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    public List<TrajetReservation> searchReservationsWithFilters(Map<String, Object> filters) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<TrajetReservation> cq = cb.createQuery(TrajetReservation.class);
            Root<TrajetReservation> root = cq.from(TrajetReservation.class);

            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();

                if (value == null) continue;

                switch (key) {
                    case "numeroSiege":
                        predicates.add(cb.equal(root.get("numeroSiege"), value));
                        break;
                    case "nomPassager":
                        predicates.add(cb.equal(root.get("nomPassager"), value));
                        break;
                    case "dateReservation":
                        predicates.add(cb.equal(root.get("dateReservation"), value));
                        break;
                    case "nombrePlaceReservation":
                        predicates.add(cb.equal(root.get("nombrePlaceReservation"), value));
                        break;
                    case "client.id":
                        predicates.add(cb.equal(root.get("client").get("id"), value));
                        break;
                    case "trajet.id":
                        predicates.add(cb.equal(root.get("trajet").get("id"), value));
                        break;
                    case "reservationStatut.id":
                        predicates.add(cb.equal(root.get("reservationStatut").get("id"), value));
                        break;
                    // Add more fields as needed
                    default:
                        // Ignore unknown filters
                        break;
                }
            }

            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }

            TypedQuery<TrajetReservation> query = em.createQuery(cq);
            return query.getResultList();
        } finally {
            em.close();
        }
    }


    public TrajetReservation createReservation(TrajetReservation reservation) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(reservation);
            tx.commit();
            return reservation;
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public TrajetReservation getReservationById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(TrajetReservation.class, id);
        } finally {
            em.close();
        }
    }

    public List<TrajetReservation> getAllReservations() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<TrajetReservation> query = em.createQuery("SELECT r FROM TrajetReservation r",
                    TrajetReservation.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public List<TrajetReservation> getReservationsByTrajetId(Long trajetId) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<TrajetReservation> query = em.createQuery(
                    "SELECT r FROM TrajetReservation r WHERE r.trajet.id = :trajetId",
                    TrajetReservation.class);
            query.setParameter("trajetId", trajetId);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public TrajetReservation updateReservation(TrajetReservation reservation) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            TrajetReservation updated = em.merge(reservation);
            tx.commit();
            return updated;
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public void deleteReservation(Long id) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            TrajetReservation reservation = em.find(TrajetReservation.class, id);
            if (reservation != null) {
                em.remove(reservation);
            }
            tx.commit();
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    /**
     * Obtient les statistiques de rÃ©servations par statut
     *
     * @return Map avec le libellÃ© du statut comme clÃ© et le nombre de rÃ©servations
     * comme valeur
     */
    public Map<String, Long> getReservationStatsByStatus() {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT r.reservationStatut.libelle, COUNT(r) FROM TrajetReservation r GROUP BY r.reservationStatut.libelle";
            TypedQuery<Object[]> query = em.createQuery(jpql, Object[].class);
            List<Object[]> results = query.getResultList();

            Map<String, Long> stats = new HashMap<>();
            for (Object[] result : results) {
                stats.put((String) result[0], (Long) result[1]);
            }
            return stats;
        } finally {
            em.close();
        }
    }

    /**
     * Calcule le nombre total de places rÃ©servÃ©es pour un trajet
     *
     * @param trajetId ID du trajet
     * @return Nombre total de places rÃ©servÃ©es
     */
    public int getPlacesPrisesForTrajet(Long trajetId) {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT COALESCE(SUM(r.nombrePlaceReservation), 0) FROM TrajetReservation r " +
                    "WHERE r.trajet.id = :trajetId AND r.reservationStatut.libelle != 'AnnulÃ©e'";
            TypedQuery<Long> query = em.createQuery(jpql, Long.class);
            query.setParameter("trajetId", trajetId);
            Long result = query.getSingleResult();
            return result != null ? result.intValue() : 0;
        } finally {
            em.close();
        }
    }

    /**
     * Calcule le nombre de places restantes pour un trajet
     *
     * @param trajetId ID du trajet
     * @return Nombre de places restantes
     */
    public int getPlacesRestantesForTrajet(Long trajetId) {
        EntityManager em = emf.createEntityManager();
        try {
            Trajet trajet = em.find(Trajet.class, trajetId);
            if (trajet == null) {
                return 0;
            }

            int capaciteMax = trajet.getVehicule().getMaximumPassager();
            int placesPrises = getPlacesPrisesForTrajet(trajetId);

            return capaciteMax - placesPrises;
        } finally {
            em.close();
        }
    }

    /**
     * Calcule le total de places prises pour tous les trajets
     *
     * @return Nombre total de places rÃ©servÃ©es
     */
    public int getTotalPlacesPrises() {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT COALESCE(SUM(r.nombrePlaceReservation), 0) FROM TrajetReservation r " +
                    "WHERE r.reservationStatut.libelle != 'AnnulÃ©e'";
            TypedQuery<Long> query = em.createQuery(jpql, Long.class);
            Long result = query.getSingleResult();
            return result != null ? result.intValue() : 0;
        } finally {
            em.close();
        }
    }

    /**
     * Calcule le total de places restantes pour tous les trajets
     *
     * @return Nombre total de places restantes
     */
    public int getTotalPlacesRestantes() {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT t FROM Trajet t";
            TypedQuery<Trajet> query = em.createQuery(jpql, Trajet.class);
            List<Trajet> trajets = query.getResultList();

            int totalCapacite = 0;
            for (Trajet trajet : trajets) {
                totalCapacite += trajet.getVehicule().getMaximumPassager();
            }

            int totalPlacesPrises = getTotalPlacesPrises();
            return totalCapacite - totalPlacesPrises;
        } finally {
            em.close();
        }
    }
    public List<TrajetReservationPaiement> getPaymentsByReservation(Long reservationId) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<TrajetReservationPaiement> query = em.createQuery(
                    "SELECT p FROM TrajetReservationPaiement p WHERE p.trajetReservation.id = :id ORDER BY p.datePaiement DESC",
                    TrajetReservationPaiement.class);
            query.setParameter("id", reservationId);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public double getTotalPaiementRecu (Long idReservation ) {

    }

    public TrajetReservationPaiement createPayment(TrajetReservationPaiement paiement) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(paiement);
            tx.commit();
            return paiement;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public List<TrajetReservationMouvementStatut> getStatusHistoryByReservation(Long reservationId) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<TrajetReservationMouvementStatut> query = em.createQuery(
                    "SELECT rms FROM TrajetReservationMouvementStatut rms WHERE rms.trajetReservation.id = :id ORDER BY rms.dateMouvement DESC",
                    TrajetReservationMouvementStatut.class);
            query.setParameter("id", reservationId);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public TrajetReservationMouvementStatut changeStatus(TrajetReservationMouvementStatut mouvement) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(mouvement);
            tx.commit();
            return mouvement;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.dto.StatusObjectDto;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.TypedQuery;
import java.util.List;

/**
 * Service gÃ©nÃ©rique pour gÃ©rer les statuts (Chauffeur, Vehicule, Trajet, Reservation)
 */
public class StatusService {
    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    /**
     * RÃ©cupÃ¨re tous les statuts pour une table donnÃ©e
     * @param tableName Nom de la table (Chauffeur_Statut, Vehicule_Statut, Trajet_Statut, Reservation_Statut)
     * @return Liste des statuts
     */
    public List<StatusObjectDto> findAllStatuses(String tableName) {
        String entityName = getStatusEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.StatusObjectDto(s.id, s.libelle, s.score, s.spanHtml) " +
                    "FROM " + entityName + " s ORDER BY s.score";
            TypedQuery<StatusObjectDto> query = em.createQuery(jpql, StatusObjectDto.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    /**
     * Trouve un statut par son libellÃ©
     * @param tableName Nom de la table
     * @param libelle LibellÃ© du statut
     * @return Le statut ou null
     */
    public StatusObjectDto findStatusByLibelle(String tableName, String libelle) {
        String entityName = getStatusEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.StatusObjectDto(s.id, s.libelle, s.score, s.spanHtml) " +
                    "FROM " + entityName + " s WHERE s.libelle = :libelle";
            TypedQuery<StatusObjectDto> query = em.createQuery(jpql, StatusObjectDto.class);
            query.setParameter("libelle", libelle);
            List<StatusObjectDto> results = query.getResultList();
            return results.isEmpty() ? null : results.get(0);
        } finally {
            em.close();
        }
    }

    /**
     * Trouve un statut par son score
     * @param tableName Nom de la table
     * @param score Score du statut
     * @return Le statut ou null
     */
    public StatusObjectDto findStatusByScore(String tableName, int score) {
        String entityName = getStatusEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.StatusObjectDto(s.id, s.libelle, s.score, s.spanHtml) " +
                    "FROM " + entityName + " s WHERE s.score = :score";
            TypedQuery<StatusObjectDto> query = em.createQuery(jpql, StatusObjectDto.class);
            query.setParameter("score", score);
            List<StatusObjectDto> results = query.getResultList();
            return results.isEmpty() ? null : results.get(0);
        } finally {
            em.close();
        }
    }

    /**
     * Trouve un statut par son ID
     * @param tableName Nom de la table
     * @param id ID du statut
     * @return Le statut ou null
     */
    public StatusObjectDto findStatusById(String tableName, Long id) {
        String entityName = getStatusEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.StatusObjectDto(s.id, s.libelle, s.score, s.spanHtml) " +
                    "FROM " + entityName + " s WHERE s.id = :id";
            TypedQuery<StatusObjectDto> query = em.createQuery(jpql, StatusObjectDto.class);
            query.setParameter("id", id);
            List<StatusObjectDto> results = query.getResultList();
            return results.isEmpty() ? null : results.get(0);
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re les statuts avec un score minimum
     * @param tableName Nom de la table
     * @param minScore Score minimum
     * @return Liste des statuts
     */
    public List<StatusObjectDto> findStatusesByMinScore(String tableName, int minScore) {
        String entityName = getStatusEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.StatusObjectDto(s.id, s.libelle, s.score, s.spanHtml) " +
                    "FROM " + entityName + " s WHERE s.score >= :minScore ORDER BY s.score";
            TypedQuery<StatusObjectDto> query = em.createQuery(jpql, StatusObjectDto.class);
            query.setParameter("minScore", minScore);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re les statuts avec un score maximum
     * @param tableName Nom de la table
     * @param maxScore Score maximum
     * @return Liste des statuts
     */
    public List<StatusObjectDto> findStatusesByMaxScore(String tableName, int maxScore) {
        String entityName = getStatusEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.StatusObjectDto(s.id, s.libelle, s.score, s.spanHtml) " +
                    "FROM " + entityName + " s WHERE s.score <= :maxScore ORDER BY s.score";
            TypedQuery<StatusObjectDto> query = em.createQuery(jpql, StatusObjectDto.class);
            query.setParameter("maxScore", maxScore);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    /**
     * RÃ©cupÃ¨re les statuts dans une plage de scores
     * @param tableName Nom de la table
     * @param minScore Score minimum
     * @param maxScore Score maximum
     * @return Liste des statuts
     */
    public List<StatusObjectDto> findStatusesByScoreRange(String tableName, int minScore, int maxScore) {
        String entityName = getStatusEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.StatusObjectDto(s.id, s.libelle, s.score, s.spanHtml) " +
                    "FROM " + entityName + " s WHERE s.score BETWEEN :minScore AND :maxScore ORDER BY s.score";
            TypedQuery<StatusObjectDto> query = em.createQuery(jpql, StatusObjectDto.class);
            query.setParameter("minScore", minScore);
            query.setParameter("maxScore", maxScore);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    /**
     * Mapping des noms de tables vers les noms d'entitÃ©s de statut
     */
    private String getStatusEntityName(String tableName) {
        return switch (tableName) {
            case "Chauffeur" -> "ChauffeurStatut";
            case "Vehicule" -> "VehiculeStatut";
            case "Trajet" -> "TrajetStatut";
            case "Trajet_Reservation" -> "ReservationStatut";
            default -> throw new IllegalArgumentException("Table non supportÃ©e: " + tableName);
        };
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.entity.Trajet;
import com.mdgtaxi.entity.TrajetReservation;
import com.mdgtaxi.entity.TrajetReservationDetails;
import com.mdgtaxi.entity.TrajetReservationPaiement;
import com.mdgtaxi.entity.VehiculeTarifTypePlace;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class TrajetService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    public Trajet createTrajet(Trajet trajet) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(trajet);
            tx.commit();
            return trajet;
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public Trajet getTrajetById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(Trajet.class, id);
        } finally {
            em.close();
        }
    }

    public List<Trajet> getAllTrajets() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Trajet> query = em.createQuery("SELECT t FROM Trajet t ORDER BY t.datetimeDepart DESC", Trajet.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public List<Trajet> getTrajetsByLigneId(Long ligneId) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Trajet> query = em.createQuery(
                    "SELECT t FROM Trajet t WHERE t.ligne.id = :ligneId ORDER BY t.datetimeDepart DESC",
                    Trajet.class);
            query.setParameter("ligneId", ligneId);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public double getPlaceRestante(Long idTrajet) {
        EntityManager em = emf.createEntityManager();
        try {
            Trajet trajet = em.find(Trajet.class, idTrajet);
            if (trajet == null) {
                return 0.0;
            }
            double totalPlaces = trajet.getVehicule().getMaximumPassager();
            String jpql = "SELECT SUM(trd.nombrePlaces) FROM TrajetReservation tr JOIN tr.trajetReservationDetails trd WHERE tr.trajet.id = :idTrajet";
            TypedQuery<Double> query = em.createQuery(jpql, Double.class);
            query.setParameter("idTrajet", idTrajet);
            Double taken = query.getSingleResult();
            double takenPlaces = taken != null ? taken : 0.0;
            return totalPlaces - takenPlaces;
        } finally {
            em.close();
        }
    }

    public double getPlaceRestante(Long idTrajet, Long idTypePlace) {
        EntityManager em = emf.createEntityManager();
        try {
            Trajet trajet = em.find(Trajet.class, idTrajet);
            if (trajet == null) {
                return 0.0;
            }
            String totalJpql = "SELECT vttp.nombrePlace FROM VehiculeTarifTypePlace vttp WHERE vttp.vehicule.id = :idVehicule AND vttp.typePlace.id = :idTypePlace";
            TypedQuery<Double> totalQuery = em.createQuery(totalJpql, Double.class);
            totalQuery.setParameter("idVehicule", trajet.getVehicule().getId());
            totalQuery.setParameter("idTypePlace", idTypePlace);
            Double total = totalQuery.getSingleResult();
            double totalForType = total != null ? total : 0.0;

            String takenJpql = "SELECT SUM(trd.nombrePlaces) FROM TrajetReservation tr JOIN tr.trajetReservationDetails trd WHERE tr.trajet.id = :idTrajet AND trd.typePlace.id = :idTypePlace";
            TypedQuery<Double> takenQuery = em.createQuery(takenJpql, Double.class);
            takenQuery.setParameter("idTrajet", idTrajet);
            takenQuery.setParameter("idTypePlace", idTypePlace);
            Double taken = takenQuery.getSingleResult();
            double takenForType = taken != null ? taken : 0.0;

            return totalForType - takenForType;
        } finally {
            em.close();
        }
    }

    public double getPlacePrise(Long idTrajet, Long idTypePlace) {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT SUM(trd.nombrePlaces) FROM TrajetReservation tr JOIN tr.trajetReservationDetails trd WHERE tr.trajet.id = :idTrajet AND trd.typePlace.id = :idTypePlace";
            TypedQuery<Double> query = em.createQuery(jpql, Double.class);
            query.setParameter("idTrajet", idTrajet);
            query.setParameter("idTypePlace", idTypePlace);
            Double taken = query.getSingleResult();
            return taken != null ? taken : 0.0;
        } finally {
            em.close();
        }
    }

    public double getPrevisionChiffreAffaire(Long idTrajet) {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT SUM(trd.nombrePlaces * vttp.tarifUnitaire) " +
                    "FROM TrajetReservation tr " +
                    "JOIN tr.trajetReservationDetails trd " +
                    "JOIN VehiculeTarifTypePlace vttp ON vttp.vehicule.id = tr.trajet.vehicule.id AND vttp.typePlace.id = trd.typePlace.id " +
                    "WHERE tr.trajet.id = :idTrajet";
            TypedQuery<Double> query = em.createQuery(jpql, Double.class);
            query.setParameter("idTrajet", idTrajet);
            Double prevision = query.getSingleResult();
            return prevision != null ? prevision : 0.0;
        } finally {
            em.close();
        }
    }

    public double getTotalPaiementRecu(Long idTrajet) {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT SUM(p.montant.doubleValue) FROM TrajetReservationPaiement p WHERE p.trajetReservation.trajet.id = :idTrajet";
            TypedQuery<Double> query = em.createQuery(jpql, Double.class);
            query.setParameter("idTrajet", idTrajet);
            Double total = query.getSingleResult();
            return total != null ? total : 0.0;
        } finally {
            em.close();
        }
    }

    public List<Trajet> searchTrajetsWithFilters(Map<String, Object> filters) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Trajet> cq = cb.createQuery(Trajet.class);
            Root<Trajet> root = cq.from(Trajet.class);

            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();

                if (value == null) continue;

                switch (key) {
                    case "nombrePassager":
                        predicates.add(cb.equal(root.get("nombrePassager"), value));
                        break;
                    case "datetimeDepart":
                        predicates.add(cb.equal(root.get("datetimeDepart"), value));
                        break;
                    case "datetimeDepart>=":
                        predicates.add(cb.greaterThanOrEqualTo(root.get("datetimeDepart"), (LocalDateTime) value));
                        break;
                    case "datetimeDepart<=":
                        predicates.add(cb.lessThanOrEqualTo(root.get("datetimeDepart"), (LocalDateTime) value));
                        break;
                    case "datetimeArrivee":
                        predicates.add(cb.equal(root.get("datetimeArrivee"), value));
                        break;
                    case "datetimeArrivee>=":
                        predicates.add(cb.greaterThanOrEqualTo(root.get("datetimeArrivee"), (LocalDateTime) value));
                        break;
                    case "datetimeArrivee<=":
                        predicates.add(cb.lessThanOrEqualTo(root.get("datetimeArrivee"), (LocalDateTime) value));
                        break;
                    case "fraisUnitaire":
                        predicates.add(cb.equal(root.get("fraisUnitaire"), value));
                        break;
                    case "ligne.id":
                        predicates.add(cb.equal(root.get("ligne").get("id"), value));
                        break;
                    case "chauffeur.id":
                        predicates.add(cb.equal(root.get("chauffeur").get("id"), value));
                        break;
                    case "vehicule.id":
                        predicates.add(cb.equal(root.get("vehicule").get("id"), value));
                        break;
                    case "trajetStatut.id":
                        predicates.add(cb.equal(root.get("trajetStatut").get("id"), value));
                        break;
                    default:
                        // Ignore unknown filters
                        break;
                }
            }

            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }

            cq.orderBy(cb.desc(root.get("datetimeDepart")));

            TypedQuery<Trajet> query = em.createQuery(cq);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public Trajet updateTrajet(Trajet trajet) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Trajet updated = em.merge(trajet);
            tx.commit();
            return updated;
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public void deleteTrajet(Long id) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Trajet trajet = em.find(Trajet.class, id);
            if (trajet != null) {
                em.remove(trajet);
            }
            tx.commit();
        } catch (Exception e) {
            if (tx.isActive())
                tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }
    public List<Trajet> getAllUpcomingTrajets(LocalDateTime now) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Trajet> query = em.createQuery(
                    "SELECT t FROM Trajet t WHERE t.datetimeDepart >= :now ORDER BY t.datetimeDepart ASC",
                    Trajet.class
            );
            query.setParameter("now", now);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public List<Trajet> getUpcomingTrajetsByLigne(LocalDateTime now, Long ligneId) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Trajet> query = em.createQuery(
                    "SELECT t FROM Trajet t WHERE t.datetimeDepart >= :now AND t.ligne.id = :ligneId ORDER BY t.datetimeDepart ASC",
                    Trajet.class
            );
            query.setParameter("now", now);
            query.setParameter("ligneId", ligneId);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public List<Trajet> getUpcomingTrajetsByLigneAndDate(LocalDateTime now, Long ligneId, LocalDate date) {
        LocalDateTime start = now.isAfter(date.atStartOfDay()) ? now : date.atStartOfDay();
        LocalDateTime end = date.plusDays(1).atStartOfDay();
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Trajet> query = em.createQuery(
                    "SELECT t FROM Trajet t WHERE t.datetimeDepart >= :start AND t.datetimeDepart < :end AND t.ligne.id = :ligneId ORDER BY t.datetimeDepart ASC",
                    Trajet.class
            );
            query.setParameter("start", start);
            query.setParameter("end", end);
            query.setParameter("ligneId", ligneId);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public List<LocalDate> getDistinctUpcomingDatesByLigne(LocalDateTime now, Long ligneId) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<LocalDateTime> query = em.createQuery(
                    "SELECT t.datetimeDepart FROM Trajet t WHERE t.datetimeDepart >= :now AND t.ligne.id = :ligneId ORDER BY t.datetimeDepart ASC",
                    LocalDateTime.class
            );
            query.setParameter("now", now);
            query.setParameter("ligneId", ligneId);
            List<LocalDateTime> dateTimes = query.getResultList();
            return dateTimes.stream()
                    .map(LocalDateTime::toLocalDate)
                    .distinct()
                    .sorted()
                    .collect(Collectors.toList());
        } finally {
            em.close();
        }
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.dto.TypeObjectDTO;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.TypedQuery;
import java.util.List;

public class TypeObjectService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    public List<TypeObjectDTO> findAllTypeObject(String tableName) {
        // Mapping des noms de tables vers les noms d'entitÃ©s JPA
        String entityName = getEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.TypeObjectDTO(e.id, e.libelle) FROM " + entityName + " e";
            TypedQuery<TypeObjectDTO> query = em.createQuery(jpql, TypeObjectDTO.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public TypeObjectDTO findTypeObjectByLibelle(String tableName, String libelle) {
        String entityName = getEntityName(tableName);

        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT new com.mdgtaxi.dto.TypeObjectDTO(e.id, e.libelle) FROM " + entityName
                    + " e WHERE e.libelle = :libelle";
            TypedQuery<TypeObjectDTO> query = em.createQuery(jpql, TypeObjectDTO.class);
            query.setParameter("libelle", libelle);
            List<TypeObjectDTO> results = query.getResultList();
            return results.isEmpty() ? null : results.get(0);
        } finally {
            em.close();
        }
    }

    private String getEntityName(String tableName) {
        return tableName.replace("_", "");
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.entity.CarburantType;
import com.mdgtaxi.entity.Vehicule;
import com.mdgtaxi.entity.VehiculeEntretien;
import com.mdgtaxi.entity.VehiculeMouvementStatut;
import com.mdgtaxi.entity.VehiculeStatut;
import com.mdgtaxi.entity.VehiculeTarifTypePlace;
import com.mdgtaxi.entity.VehiculeType;
import com.mdgtaxi.util.HibernateUtil;
import com.mdgtaxi.view.VmVehiculeCoutEntretien;
import com.mdgtaxi.view.VmVehiculeDetail;
import com.mdgtaxi.view.VmVehiculeHistoriqueStatut;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class VehiculeService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    // CRUD Operations for Vehicule

    public Vehicule createVehicule(Vehicule vehicule) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(vehicule);
            tx.commit();
            return vehicule;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public Vehicule getVehiculeById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(Vehicule.class, id);
        } finally {
            em.close();
        }
    }

    public List<Vehicule> getAllVehicules() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Vehicule> query = em.createQuery("SELECT v FROM Vehicule v", Vehicule.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public Vehicule updateVehicule(Vehicule vehicule) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Vehicule updated = em.merge(vehicule);
            tx.commit();
            return updated;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public void deleteVehicule(Long id) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            Vehicule vehicule = em.find(Vehicule.class, id);
            if (vehicule != null) {
                em.remove(vehicule);
            }
            tx.commit();
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    // Operations using Views

    public VmVehiculeDetail getVehiculeDetail(Long idVehicule) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(VmVehiculeDetail.class, idVehicule);
        } finally {
            em.close();
        }
    }

    public List<VmVehiculeDetail> getAllVehiculeDetails() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<VmVehiculeDetail> query = em.createQuery("SELECT vd FROM VmVehiculeDetail vd", VmVehiculeDetail.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }



    public List<VmVehiculeHistoriqueStatut> getHistoriqueStatut(Long idVehicule) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<VmVehiculeHistoriqueStatut> query = em.createQuery(
                    "SELECT hs FROM VmVehiculeHistoriqueStatut hs WHERE hs.idVehicule = :idVehicule ORDER BY hs.dateMouvement DESC",
                    VmVehiculeHistoriqueStatut.class);
            query.setParameter("idVehicule", idVehicule);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public VmVehiculeCoutEntretien getCoutEntretien(Long idVehicule) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.find(VmVehiculeCoutEntretien.class, idVehicule);
        } finally {
            em.close();
        }
    }

    // Operations for Related Entities

    public VehiculeEntretien addEntretien(VehiculeEntretien entretien) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(entretien);
            tx.commit();
            return entretien;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    public List<VehiculeEntretien> getEntretiensByVehicule(Long idVehicule) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<VehiculeEntretien> query = em.createQuery(
                    "SELECT ve FROM VehiculeEntretien ve WHERE ve.vehicule.id = :idVehicule ORDER BY ve.dateDebutEntretien DESC",
                    VehiculeEntretien.class);
            query.setParameter("idVehicule", idVehicule);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public double getTotalMaxChiffreAffairePossible(Long idVoiture) {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT SUM(vttp.nombrePlace * vttp.tarifUnitaire) FROM VehiculeTarifTypePlace vttp WHERE vttp.vehicule.id = :idVoiture";
            TypedQuery<Double> query = em.createQuery(jpql, Double.class);
            query.setParameter("idVoiture", idVoiture);
            Double total = query.getSingleResult();
            return total != null ? total : 0.0;
        } finally {
            em.close();
        }
    }

    public double getTotalMaxChiffreAffairePossible(Long idVoiture, Long idTypePlace) {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = "SELECT vttp.nombrePlace * vttp.tarifUnitaire FROM VehiculeTarifTypePlace vttp WHERE vttp.vehicule.id = :idVoiture AND vttp.typePlace.id = :idTypePlace";
            TypedQuery<Double> query = em.createQuery(jpql, Double.class);
            query.setParameter("idVoiture", idVoiture);
            query.setParameter("idTypePlace", idTypePlace);
            Double total = query.getSingleResult();
            return total != null ? total : 0.0;
        } finally {
            em.close();
        }
    }

    public VehiculeMouvementStatut changeStatut(VehiculeMouvementStatut mouvement) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            em.persist(mouvement);
            tx.commit();
            return mouvement;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }

    // Multi-filter criteria function for Vehicule (using Criteria API)
    // Filters are provided as a Map<String, Object> where keys are field names like "marque", "modele", "immatriculation", etc.
    // For relationships, use "vehiculeType.libelle", "carburantType.libelle"
    // Supports exact match for strings, equality for numbers, etc.

    public List<Vehicule> searchVehiculesWithFilters(Map<String, Object> filters) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Vehicule> cq = cb.createQuery(Vehicule.class);
            Root<Vehicule> root = cq.from(Vehicule.class);

            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();

                if (value == null) continue;

                switch (key) {
                    case "marque":
                        predicates.add(cb.equal(root.get("marque"), value));
                        break;
                    case "modele":
                        predicates.add(cb.equal(root.get("modele"), value));
                        break;
                    case "immatriculation":
                        predicates.add(cb.equal(root.get("immatriculation"), value));
                        break;
                    case "maximumPassager":
                        predicates.add(cb.equal(root.get("maximumPassager"), value));
                        break;
                    case "capaciteCarburant":
                        predicates.add(cb.equal(root.get("capaciteCarburant"), value));
                        break;
                    case "depenseCarburant100km":
                        predicates.add(cb.equal(root.get("depenseCarburant100km"), value));
                        break;
                    case "vehiculeType.libelle":
                        predicates.add(cb.equal(root.get("vehiculeType").get("libelle"), value));
                        break;
                    case "carburantType.libelle":
                        predicates.add(cb.equal(root.get("carburantType").get("libelle"), value));
                        break;
                    // Add more fields as needed
                    default:
                        // Ignore unknown filters
                        break;
                }
            }

            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }

            TypedQuery<Vehicule> query = em.createQuery(cq);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    // New methods for VehiculeTarifTypePlace

    public List<VehiculeTarifTypePlace> getTarifTypePlacesByVehicule(Long idVehicule) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<VehiculeTarifTypePlace> query = em.createQuery(
                    "SELECT vttp FROM VehiculeTarifTypePlace vttp WHERE vttp.vehicule.id = :idVehicule",
                    VehiculeTarifTypePlace.class);
            query.setParameter("idVehicule", idVehicule);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public VehiculeTarifTypePlace getTarifTypePlaceByVehiculeAndType(Long idVehicule, Long idTypePlace) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<VehiculeTarifTypePlace> query = em.createQuery(
                    "SELECT vttp FROM VehiculeTarifTypePlace vttp WHERE vttp.vehicule.id = :idVehicule AND vttp.typePlace.id = :idTypePlace",
                    VehiculeTarifTypePlace.class);
            query.setParameter("idVehicule", idVehicule);
            query.setParameter("idTypePlace", idTypePlace);
            List<VehiculeTarifTypePlace> results = query.getResultList();
            return results.isEmpty() ? null : results.get(0);
        } finally {
            em.close();
        }
    }

    public VehiculeTarifTypePlace createOrUpdateTarifTypePlace(VehiculeTarifTypePlace vttp) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        try {
            tx.begin();
            if (vttp.getId() != null) {
                vttp = em.merge(vttp);
            } else {
                em.persist(vttp);
            }
            tx.commit();
            return vttp;
        } catch (Exception e) {
            if (tx.isActive()) tx.rollback();
            throw e;
        } finally {
            em.close();
        }
    }
}
package com.mdgtaxi.service;

import com.mdgtaxi.entity.Ville;
import com.mdgtaxi.util.HibernateUtil;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class VilleService {

    private final EntityManagerFactory emf = HibernateUtil.getEntityManagerFactory();

    public List<Ville> getAllVilles() {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<Ville> query = em.createQuery("SELECT v FROM Ville v", Ville.class);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    public List<Ville> searchVillesWithFilters(Map<String, Object> filters) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Ville> cq = cb.createQuery(Ville.class);
            Root<Ville> root = cq.from(Ville.class);

            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();

                if (value == null) continue;

                switch (key) {
                    case "nom":
                        predicates.add(cb.equal(root.get("nom"), value));
                        break;
                    case "region.id":
                        predicates.add(cb.equal(root.get("region").get("id"), value));
                        break;
                    // Add more fields as needed
                    default:
                        // Ignore unknown filters
                        break;
                }
            }

            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }

            TypedQuery<Ville> query = em.createQuery(cq);
            return query.getResultList();
        } finally {
            em.close();
        }
    }
}
